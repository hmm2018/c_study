#include <stdio.h>
#include <string.h>
//1. 数组
/* int main()
{
    int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}; //定义一个存放10个整数数字的数组
    int i = 0;
    while (i < 10)
    {
        printf("%d ", arr[i]);
        i++;
    }
    return 0;
} */

//2.运算符 * / %
/* int main()
{
    // int a = 5 / 2;
    // printf("%d\n", a);

    // int a = 5 % 2; //取模
    // printf("%d\n", a);

    return 0;
} */

//3.移(2进制)位操作
/*int main()
{
    // << 左移
    // >> 右移
    int a = 1;
    // 整型1占4个字节，即32个bit位
    //1的二进制序列的表达:00000000000000000000000000000001

    // int b = a << 1; //把a向左移动1位，定义b来接收;
    // a 左移1位变成: 00000000000000000000000000000010
    // printf("%d\n", b); //=>b的值为2 1*2^1=2;

    int b = a << 2; //把a的值向左移动2位，定义一个b来接收
    // a 左移2位变成: 00000000000000000000000000000100
    printf("%d\n", b); //=>b 的值为4 1*2^2 = 4;
    printf("%d\n", a); //当对a进行左移或右移操作时，a的值不变;
    return 0;
}*/

// 练习：进制转换，十进制转二进制； 二进制转十进制

// 4.(2进制)位操作
// & 按位与: 只有两个数的二进制同时为1，结果才为1，否则为0;
// | 按位或: 参与运算的两个数只要两个数中一个为1，结果就为1;
// ^ 按位异或:对应的二进制位 相同则为0，相异则为1
/* int main()
{
    int a = 3; //转成2进制 011 => 0*2^2 + 1*2^1 + 1*2^0
    int b = 5; //转成2进制 101 => 1*2^2 + 0*2^1 + 1*2^0
    // int c = a & b; //          001 => 0*2^2 + 0*2^1 + 1*2^0
    // printf("%d\n", c); => c的值为1

    // int c = a | b;     //          111 => 1*2^2 + 1*2^1 + 1*2^0
    // printf("%d\n", c); // => c的值为7

    int c = a ^ b;     //     110 =>1*2^2 + 1*2^1 + 0*2^0;
    printf("%d\n", c); //=> c的值为 6

    return 0;
} */

// 5.单目运算符
// 5-1:sizeof 计算的是变量/类型所占空间的大小，单位是字节
/* int main()
{
    // 特别提示:数组的大小是常量来指定，不能用变量指定，所有下行代码错误
    //int n = 10;
    //int arr[n] = {}; // 数组的大小是常量来指定,n是变量，不能这么用

    // int a = 10;
    // printf("%d\n", sizeof(a));   // =>4
    // printf("%d\n", sizeof(int)); //=>4

    // 计算数组元素的个数
    int arr[10] = {0};
    int sz = 0;
    // 10*sizeof(int) =>40
    printf("%d\n", sizeof(arr));

    // 计算数组的元素个数
    // 个数 = 数组总大小/每个元素的大小
    sz = sizeof(arr) / sizeof(arr[0]);
    printf("sz=%d\n", sz);
    return 0;
} */

// 5.单目运算符
// 5.2:  ~按(2进制)位取反
/* int main()
{
    int a = 0;  //4个字节，32个bit位
    int b = ~a; // 此处的b 是有符号的整型，有符号的整型(二进制中)最高位是符号位，
    // 符号位如果为1，表示是一个负数;符号位如果为0，表示是一个正数

    // 0 的二进制序列表示形式：00000000000000000000000000000000
    // 按位取反=>             11111111111111111111111111111111

    // 原码  反码  补码
    // 只要是整数，内存中存储的都是二进制的补码
    // 正整数原码 反码 补码 相同
    // 负数在内存中存储的时候，存储的是二进制的补码

    // 原码：直接按照正负写出的二进制序列
    // 反码：原码符号位不变，其他位按位取反得到的
    // 补码：反码+1得到的

    举个栗子：-2
    // -2的原码：10000000000000000000000000000010
    // -2的反码：11111111111111111111111111111101
    // -2的补码：11111111111111111111111111111110




    // 原码  反码  补码的计算规则：
    // 原码==>反码=>补码： 原码符号位不变，其他位按位取反 得到反码;反码+1,得到补码
    // 补码=>反码=>原码：  补码减1,得到反码，反码按位取反得到原码；
    // 举个栗子：0 的二进制序列表示形式：00000000000000000000000000000000
    // 补码为:                           11111111111111111111111111111111
    // 反码为：                          11111111111111111111111111111110
    // 原码为：                          10000000000000000000000000000001  =>最高位是1,表示是负号，最后一位是1，所以b的结果为-1

    printf("%d\n", b); //b 输出的是-1.原因：使用的、打印的是这个数的原码

    return 0;
} */

// 5.单目运算符
// 5.3:  ++ --
/* int main()
{
    int a = 10;
    // int b = a++; //后置++ ,先运算后自增1，同js
    int b = ++a; //前置++ ,先自增1后运算，同js
    printf("a=%d b=%d\n", a, b);
    return 0;
} */

// 6.逻辑运算符(同js 的逻辑运算符)
/* int main()
{
    // 真 --非0
    // 假 --0
    // && - 逻辑与 //同真为真，一假则假
    // || - 逻辑或  //一真为真，同假则假
    int a = 2;
    int b = 5;
    int c = a && b;
    printf("c= %d\n", c);
    return 0;
} */
// 7.条件操作符(同js 的三目运算符)
// 8.逗号表达式 用逗号隔开的表达式

// 9.下标引用操作符[],函数调用操作符()
/* int Add(int x, int y)
{
    int z = 0;
    z = x + y;
    return z;
}

int main()
{
    int arr[10] = {0};
    // arr[4]  //[] 下标引用操作符

    int a = 10;
    int b = 20;
    int sum = Add(a, b); //()函数调用操作符
    return 0;
} */

//练习题 求两个函数中的较大值
/* int Max(int x, int y)
{
    if (x > y)
        return x;
    else
        return y;
}
int main()
{
    int num1 = 10;
    int num2 = 20;
    int max = 0;
    max = Max(num1, num2);
    printf("max = %d\n", max);
    return 0;
} */

// C语言常见的关键字
// 1.auto  局部变量前面的关键字
/* int main()
{
    auto int a = 10; //局部变量也叫自动变量
    return 0;
} */
// 2.enum 枚举
// 3.extern  引入外部符号
// 4.goto 语句
// 5.register  寄存器关键字
/* int main()
{
    register int a = 10; //建议把a定义成寄存器变量
    return 0;
} */
// 6.int等价于signed int 定义的变量是有符号的，unsigned 定义的变量是无符号的；
// 7.sizeof 计算大小
// 8.static 静态的 作用：
// 8-1.static修饰局部变量，使得局部变量的生命周期变长;
// 8-2.static 修饰全局变量，让静态的全局变量只能在自己所在的源文件内部使用，出了源文件就无法使用了

/* void test()
{
    static int a = 1; //a是一个静态的局部变量，
    a++;
    printf("a = %d\n", a); //对比去掉static时的打印，凸显static的作用(使得局部变量的生命周期变长)
}
int main()
{
    int i = 0;
    while (i < 5)
    {
        test();
        i++;
    }
    return 0;
} */

// static对全局变量的作用：
/* int main()
{
    extern int g_val;
    printf("g_val = %d\n", g_val); //报错 add.c中的，g_val 被static 修饰了，无法被外部使用
    return 0;
} */

// 9.struct 结构体关键字

// 创建一个结构体类型
struct Book
{
    char name[20];
    short price;
};

int main()
{
    // 利用结构体类型创建一个该类型的结构体变量
    struct Book b1 = {"C语言程序设计", 66};
    struct Book *pb = &b1; //取出b1的地址，保存在pb中，pb是一个指针变量，它的类型是struct Book* 类型的,(struct Book*是一种指针类型)
    // 利用pb打印书名和价格,方法一：
    // printf("通过指针打印书名是:%s\n", (*pb).name);
    // printf("通过指针打印价格是: %d\n", (*pb).price);

    // 利用pb打印书名和价格,方法二：
    // printf("箭头方式找书名:%s\n", pb->name);
    // printf("箭头方式找价格:%d\n", pb->price);

    //结论：.(点操作符)用法: 结构体变量.成员
    // ->(箭头操作符)用法:  结构体指针->成员

    // 修改结构体书名的方法:
    // 由于结构体中name是数组名，要修改它里面的值须借助strcpy()这个库函数，
    // 这个函数有两个参数strcpy(要修改的结构体变量,修改后的新值)，如要修改 结构体中书名(要修改的结构体变量)，改为 "C++程序设计"(修改后的新值);
    // 所有需要引入这个函数的库文件 #include <string.h>即可修改
    strcpy(b1.name, "C++程序设计");

    printf("书名是: %s\n", b1.name);
    printf("价格是:%d元\n", b1.price);
    b1.price = 15;
    printf("修改后书名是:%s\n", b1.name);
    printf("修改后价格是:%d元\n", b1.price);
    return 0;
}

// 10 union 联合体/共用体
// 11.typedef 类型定义
/* int main()
{
    // typedef 类型定义- 类型重定义
    typedef unsigned int u_int;
    unsigned int num = 20; //等价于 u_int num =20;
    u_int num = 20;
    return 0;
} */

// void  无或空
// volatile
